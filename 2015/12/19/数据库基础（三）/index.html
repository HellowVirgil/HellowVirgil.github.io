<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 数据库基础（三） · VirgilZone</title><meta name="description" content="数据库基础（三） - Virgil"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://hellowvirgil.github.io/atom.xml" title="VirgilZone"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/HellowVirgil" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://weibo.com/u/3074324883" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="http://www.zhihu.com/people/callmevirgil" target="_blank" class="nav-list-link">ZHIHU</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">数据库基础（三）</h1><div class="post-info">Dec 19, 2015</div><div class="post-content"><h2 id="一、基本查询语句">一、基本查询语句</h2><p><strong><em>FROM 子句后面添加查找的表</em></strong></p>
<p><strong><em>字段的别名</em></strong><br>当我们在使用SELECT语句中查询内容时，若某个字段是一个函数或者表达式的时候，那么在查询结果集中对应的该字段的名字就是这个函数或者表达式，可读性差，这个时候我们可以为该函数或表达式起一个别名，这样结果集中会使用该别名作为该字段的名字。<br>使用语法是列的别名跟在列名后，中间可以加或不加 AS 关键字。<br>如果别名中有空格或者需要区分大小写，需要将别名加上双引号<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">AS</span> studentno <span class="keyword">FROM</span> student;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="string">"Student NO"</span> <span class="keyword">FROM</span> student;</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><strong><em>WHERE 子句</em></strong><br>WHERE可以用在DML语句中，也可以用在SELECT语句中，作用是添加过滤条件，只选出满足条件的记录。<br>在SELECT中使用时，当数据库查询表中数据时，每查询一条记录，都会先查看该记录是否满足条件，并将满足条件的记录查询出来。</p>
<h2 id="二、查询条件">二、查询条件</h2><p><strong><em>使用&gt;,&lt;,&gt;=,&lt;=,&lt;&gt;,= 进行判断</em></strong><br>ORACLE中也可以使用!=代替&lt;&gt;,推荐使用&lt;&gt;</p>
<p><strong><em>AND，OR 关键字</em></strong><br>如果希望返回的结果必须满足多个条件，应该使用AND逻辑操作符连接这些条件<br>如果希望返回的结果满足多个条件之一，应该使用OR逻辑操作符连接这些条件<br>AND的优先级高于OR</p>
<p><strong><em>LIKE 条件，模糊查询</em></strong><br>LIKE需要借助两个通配符：<br>% - 表示0到多个字符<br>_ - 标识单个任意字符</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> LIKE <span class="string">'_A%'</span>     <span class="comment">//匹配A为第二个字母的任意字符串</span></span><br></pre></td></tr></table></figure>
<p><strong><em>IN（list）和NOT IN（list） 比较操作符</em></strong><br>list表示值列表，当列或表达式匹配于列表中的任何一个值时，条件为true，该条记录则被显示出来<br>NOT IN取出不符合此列表中的数据记录<br>IN与NOT IN常用于子查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">IN</span>(<span class="string">'SMITH'</span>,<span class="string">'JONES'</span>)</span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>BETWEEN…AND…</em></strong><br>用来查询符合某个值域范围条件的数据<br>最常见的是使用在数字类型的数据范围上，但对字符类型和日期类型数据也同样适用</p>
<p><strong><em>ANY和ALL</em></strong><br>ANY和ALL不能单独使用，需要配合当行比较操作符&gt;、&gt;=、&lt;、&lt;=一起使用</p>
<blockquote>
<p>> ANY:大于最小<br>&lt; ANY:小于最小<br>> ALL:大于最大<br>&lt; ALL:小于最大</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sal &gt; <span class="keyword">ANY</span>(<span class="number">3000</span>,<span class="number">4000</span>,<span class="number">5000</span>)</span></span><br></pre></td></tr></table></figure>
<p><strong><em>查询条件中使用条件和表达式</em></strong><br>如UPPER，LOW</p>
<p><strong><em>DISTINCT 关键字，可以取出指定字段值相同的记录行</em></strong><br>DISTINCT必须紧跟在SELECT关键字之后<br>DISTINCT后面接多个字段会去除重复的组合<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student</span></span><br></pre></td></tr></table></figure></p>
<h2 id="三、排序">三、排序</h2><p><strong><em>ORDER BY 子句</em></strong><br>用于排序查询出来的结果集，可以对指定的字段按照升序或者降序排列<br>ORDER BY子句必须写在SELECT语句的最后面<br>ORDER BY 排序默认是按照升序进行，若在后面添加DESC则为降序<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">DESC</span></span></span><br></pre></td></tr></table></figure></p>
<p>ORDER BY 也可以对多个字段进行排序，多字段排序是有优先级，先按照第一个字段的方式排序，在第一个字段相同的那些记录中，再按照第二个字段的方式排序<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">DESC</span>,age <span class="keyword">DESC</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="四、聚合函数">四、聚合函数</h2><p>聚合函数，又称多行函数，分组函数<br>聚合函数可以将多条记录的指定字段的值进行统计，然后得出一个结果<br>聚合函数均忽略NULL值</p>
<p><strong><em>MAX和MIN 求最大值和最小值</em></strong><br>可以用来统计任何数据类型，包括数字、字符和日期<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT <span class="function"><span class="title">MAX</span><span class="params">(sal)</span></span>,<span class="function"><span class="title">MIN</span><span class="params">(sal)</span></span> FROM student</span><br></pre></td></tr></table></figure></p>
<p><strong><em>AVG和SUM 用来统计表达式的平均值和和值</em></strong><br>只能操作数字类型<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT <span class="function"><span class="title">ACG</span><span class="params">(sal)</span></span>,<span class="function"><span class="title">SUM</span><span class="params">(sal)</span></span> FROM student</span><br></pre></td></tr></table></figure></p>
<p><strong><em>如果希望不忽略NULL，可以使用NVL函数将NULL替换来解决</em></strong><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG<span class="list">(<span class="keyword">NVL</span><span class="list">(<span class="keyword">comm</span>,<span class="number">0</span>)</span>)</span> FROM student</span><br></pre></td></tr></table></figure></p>
<p><strong><em>COUNT 用来计算表中的记录条数，即统计指定字段值不为NULL的记录的条数</em></strong><br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SELECT</span> <span class="built_in">COUNT</span>(comm) <span class="keyword">FROM</span> student</span><br></pre></td></tr></table></figure></p>
<p>若要统计总数，不忽略NULL则<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SELECT</span> <span class="built_in">COUNT</span>(*) <span class="keyword">FROM</span> student</span><br></pre></td></tr></table></figure></p>
<h2 id="五、分组">五、分组</h2><p><strong><em>GROUP BY 子句</em></strong><br>GROUP BY 是为了配合聚合函数使用的，使用GROUP BY子句后，分组可以更细致，就可以不在将整张表所有记录看做一组再进行统计了，可以将表中指定的字段的值相同的记录看做一组，再进行分组统计。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(sal),<span class="keyword">MIN</span>(sal),deptno <span class="keyword">from</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno</span></span><br></pre></td></tr></table></figure></p>
<p>当SELECT子句中出现了分组函数，那么凡不在聚合函数的单独字段必须出现在GROUP BY子句中，但是反过来没有强制要求。<br>GROUP BY子句后面也可以跟多个字段，当按照多个字段分组时，是按照记录中这些字段值的组合相同的看做一组<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*),deptno,job <span class="keyword">from</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno,job</span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>HAVING 子句</em></strong><br>HAVING 子句用来对分组后的结果进一步限制，必须跟在GROUP BY后面，不能单独存在<br>使用分组函数作为判断条件只能出现在 HAVING 中<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(sal),deptno <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno <span class="keyword">HAVING</span> <span class="keyword">AVG</span>(sal) &gt; <span class="number">2000</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>WHERE是在第一次从表中查询数据的时候进行过滤，而HAVING是在查询出的数据中进行统计，然后使用统计结果再次进行过滤的。所以WHERE中不能使用分组函数。</em></strong></p>
<h2 id="六、查询语句执行顺序">六、查询语句执行顺序</h2><p> <strong><em>1.FROM子句：执行顺序从后往前、从右到左</em></strong></p>
<ul>
<li><p>数据量较少的表尽量放在后面</p>
<p><strong><em>2.WHERE子句：执行顺序自上而下、从右到左</em></strong></p>
</li>
<li><p>将能过滤掉最大数量记录的条件放在WHERE子句的最后</p>
<p><strong><em>3.GROUP BY：从左往右分组</em></strong></p>
</li>
<li>最好在GROUP BY前使用WHERE将不需要的记录在GROUP BY之前过滤掉</li>
</ul>
<p><strong><em>4.HAVING子句：消耗资源</em></strong></p>
<ul>
<li>尽量避免使用，HAVING会在检索出所有记录之后才对结果集进行过滤，需要排序等操作</li>
</ul>
<p><strong><em>5.SELECT子句：少用 *</em></strong> <strong><em>号，尽量取字段名称</em></strong></p>
<ul>
<li>ORACLE在解析过程中，通过查询数据字典将*号依次转换成所有的列名，消耗时间</li>
</ul>
<p><strong><em>6.ORDER BY子句：执行顺序为从左到右排序，消耗资源</em></strong><br><br></p>
<h2 id="七、关联查询">七、关联查询</h2><p>查询的结果可能来自多张表，要从多张表中获取数据时，就要找到这几张表中记录的对应关系，然后建立联系后分别获取。所以，连接条件（指表之间记录的对应关系）在关联查询中是十分关键的。<br>N张表关联查询，至少要有N-1个连接条件，否则会出现笛卡尔积（这是一个无用的结果集，对系统资源开销大，甚至会导致系统瘫痪）。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT emp<span class="class">.ename</span>,dept<span class="class">.dname</span> FROM emp,dept WHERE emp<span class="class">.deptno</span> = dept.deptno</span><br></pre></td></tr></table></figure></p>
<p>表可以起别名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">e</span>.ename,<span class="keyword">d</span>.dname <span class="keyword">FROM</span> amp <span class="keyword">e</span>,dept <span class="keyword">d</span> <span class="keyword">WHERE</span> <span class="keyword">e</span>.deptno = <span class="keyword">d</span>.deptno</span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>内连接</em></strong><br>内连接返回所有满足链接条件的记录<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">e</span>.ename,<span class="keyword">d</span>.dname <span class="keyword">FROM</span> emp <span class="keyword">e</span> <span class="keyword">JOIN</span> dept <span class="keyword">d</span> <span class="keyword">ON</span> <span class="keyword">e</span>.deptno=<span class="keyword">d</span>.deptno</span></span><br></pre></td></tr></table></figure></p>
<p>关联查询出现的一个问题是，不满足连接条件的数据将不会被显示到结果集中。</p>
<p><strong><em>外连接</em></strong><br>有些情况下，需要返回那些不满足连接条件的记录，这时需要使用外连接<br>外连接不仅返回满足连接条件的记录还返回不满足连接条件的记录<br>外连接分为：<br>1.左外连接：以左表为驱动表，其数据都要显示，来自右表记录中的字段在结果集中若不满足连接条件，则值为NULL.<br>2.右外连接：以右表位驱动表<br>3.全外连接：两张表的数据都要查询出来，哪边不满足哪边值为NULL<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">e</span>.ename,<span class="keyword">d</span>.dname <span class="keyword">FROM</span> emp <span class="keyword">e</span> <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> dept <span class="keyword">d</span> <span class="keyword">ON</span> <span class="keyword">e</span>.deptno=<span class="keyword">d</span>.deptno</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">e</span>.ename,<span class="keyword">d</span>.dname <span class="keyword">FROM</span> emp <span class="keyword">e</span> <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> dept <span class="keyword">d</span> <span class="keyword">ON</span> <span class="keyword">e</span>.deptno=<span class="keyword">d</span>.deptno</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">e</span>.ename,<span class="keyword">d</span>.dname <span class="keyword">FROM</span> emp <span class="keyword">e</span> <span class="keyword">FULL</span> <span class="keyword">OUTER</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>自连接</em></strong><br>自连接是一种特殊的链接查询，数据来源是一个表，即关联关系来自于单表中的多个列<br>自连接设计的目的是为了解决相同类型数据之间存在父子级关系的数据结构（典型的是树状结构）<br>自连接是通过将表用别名虚拟成两个表的方式实现，可以是等值或不等值连接<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">e</span>.<span class="keyword">name</span>,e2.<span class="keyword">name</span> <span class="keyword">FROM</span> emp <span class="keyword">e</span>,emp e2 <span class="keyword">WHERE</span> e2.empno=<span class="keyword">e</span>.empno</span></span><br></pre></td></tr></table></figure></p>
</div></article></div></section><footer><div class="paginator"><a href="/2015/12/21/数据库基础（四）/" class="prev">上一篇</a><a href="/2015/12/18/数据库基础（二）/" class="next">下一篇</a></div><div data-thread-key="2015/12/19/数据库基础（三）/" data-title="数据库基础（三）" data-url="http://hellowvirgil.github.io/2015/12/19/数据库基础（三）/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"true"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 - 2017 <a href="http://hellowvirgil.github.io">Virgil</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>