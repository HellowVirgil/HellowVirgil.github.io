<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 数据库基础（四） · VirgilZone</title><meta name="description" content="数据库基础（四） - Virgil"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://hellowvirgil.github.io/atom.xml" title="VirgilZone"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/HellowVirgil" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://weibo.com/u/3074324883" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="http://www.zhihu.com/people/callmevirgil" target="_blank" class="nav-list-link">ZHIHU</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">数据库基础（四）</h1><div class="post-info">Dec 21, 2015</div><div class="post-content"><h2 id="一、子查询">一、子查询</h2><p>当我们需要执行某条SQL语句时，需要某些查询的结果作为依据时，先期执行的这条语句就是子查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">name</span>,sal <span class="keyword">FROM</span> <span class="keyword">WHERE</span> sal &gt; （<span class="keyword">SELECT</span> sal <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'CLERK'</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>除了在SELECT中使用子查询外，也可以在DDL、DML中使用子查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myemp <span class="keyword">AS</span> (<span class="keyword">SELECT</span> <span class="keyword">e</span>.empno,<span class="keyword">e</span>.ename,<span class="keyword">e</span>.sal,<span class="keyword">e</span>.job,<span class="keyword">d</span>.deptno,<span class="keyword">d</span>.dname,<span class="keyword">d</span>.loc </span><br><span class="line">		       <span class="keyword">FROM</span> mep <span class="keyword">e</span>,dept <span class="keyword">d</span> </span><br><span class="line">		       <span class="keyword">WHERE</span> <span class="keyword">e</span>.deptno=<span class="keyword">d</span>.deptno)</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> amp <span class="keyword">WHERE</span> deptno=(<span class="keyword">SELECT</span> deptno <span class="keyword">FROM</span> <span class="keyword">WHERE</span> ename=<span class="string">'CLERK'</span>)</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong><em>子查询根据查询的结果不同可分为：</em></strong><br>1.单行单列子查询：查询结果为1个值<br>2.多行单列子查询：查询结果为一个字段，但是有多条记录<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">name</span>,job </span><br><span class="line"><span class="keyword">FROM</span> emp </span><br><span class="line"><span class="keyword">WHERE</span> job <span class="keyword">IN</span>(<span class="keyword">SELECT</span> job <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> deptno=<span class="number">10</span>)</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(sal),deptno </span><br><span class="line"><span class="keyword">FROM</span> emp </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno </span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">MIN</span>(sal) &gt; (<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(sal) <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno=<span class="number">30</span>)</span></span><br></pre></td></tr></table></figure>
<p>3.多行多列子查询：查询结果集像一张表，也常当做表来用<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">e</span>.ename,<span class="keyword">e</span>.sal,<span class="keyword">e</span>.deptno</span><br><span class="line"><span class="keyword">FROM</span> emp <span class="keyword">e</span>,(<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(sal) avg_sal,deptno</span><br><span class="line">            <span class="keyword">FROM</span> emp</span><br><span class="line">            <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno) s</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">e</span>.deptno=s.deptno</span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">e</span>,sal&gt;s.avg_sal</span></span><br></pre></td></tr></table></figure><br></p>
<p>在子查询中需要引用到主查询的字段数据，使用EXISTS关键字，EXISTS后边的子查询至少返回一行数据，则整个条件返回TRUE ,判断子查询不返回数据用NOT EXISTS<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> deptno,<span class="keyword">name</span> </span><br><span class="line"><span class="keyword">FROM</span> dept <span class="keyword">d</span> </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> amp <span class="keyword">e</span> <span class="keyword">WHERE</span> <span class="keyword">d</span>.deptno = <span class="keyword">e</span>.deptno)</span></span><br></pre></td></tr></table></figure></p>
<p>在SELECT子句中使用子查询相当于外连接<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">e</span>.ename,(<span class="keyword">SELECT</span> <span class="keyword">d</span>.dname <span class="keyword">FROM</span> dept <span class="keyword">d</span> <span class="keyword">WHERE</span> <span class="keyword">d</span>.deptno = <span class="keyword">e</span>.deptno) </span><br><span class="line"><span class="keyword">FROM</span> emp <span class="keyword">e</span>;</span></span><br></pre></td></tr></table></figure><br></p>
<h2 id="二、分页查询">二、分页查询</h2><p>当表中数据量很大时，一次性查询表中全部数据会导致数据全部加载到内存中，对系统资源占用有很大影响，响应速度也慢，但往往用户也不需要一次性将这么多数据全部查看，这时我们可以分批查询表中数据。<br>由于标准SQL没有对分页进行语法定义，所以不同的数据库中分页的语法不一致。</p>
<p><strong><em>ORACLE中有ROWNUM字段，称为伪列</em></strong><br>该字段并不存在于任何一张表中，但是可以从任何一张表去查询该字段，当查询该字段时，ORACLE只要可以从表中查询出一条记录，就会为该条记录中该字段添加行号。行号从1开始，会自动增长。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">ROWNUM</span>,<span class="keyword">name</span> <span class="keyword">FROM</span> amp <span class="keyword">where</span> <span class="keyword">ROWNUM</span> &lt;= <span class="number">5</span></span></span><br></pre></td></tr></table></figure></p>
<p>由于ROWNUM只有查询出一条数据后，才会对该记录编号，然后ROWNUM自增，所以我们不能在第一次查询表中数据时使用ROWNUM&gt;1以上的数字进行过滤，否则将得不到任何数据。为此，需要进行两次查询，第一次仅使用ROWNUM为结果集编号，再基于这个结果集进行二次查询，根据ROWNUM的编号取需要的范围内的记录。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">ROWNUM</span> rn,ename <span class="keyword">FROM</span> <span class="keyword">FROM</span> emp) <span class="keyword">WHERE</span> rn &gt;= <span class="number">5</span> <span class="keyword">AND</span> rn &lt;= <span class="number">10</span></span></span><br></pre></td></tr></table></figure></p>
<p>当分页查询有排序需求时，要先排序再编号，原因在于：使用ROWNUM对结果集编号是在查询过程中进行的，而ORDER BY排序是在查询出结果后进行的。所以，当排序过后，原本的编号顺序就打乱了。为此，我们要先排序，再将排序后的结果集进行编号，才能得到正确的结果。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span>（<span class="keyword">SELECT</span> <span class="keyword">ROWNUM</span> rn,<span class="keyword">t</span>.* </span><br><span class="line">      <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal <span class="keyword">DESC</span>)  <span class="keyword">t</span>）</span><br><span class="line"><span class="keyword">WHERE</span> rn &gt; <span class="number">5</span> <span class="keyword">AND</span> rn &lt;= <span class="number">10</span></span></span><br></pre></td></tr></table></figure></p>
<p>pageSize：每页显示的条目数<br>page：页数<br>start = （page - 1）<em> pageSize + 1<br>end = page</em>pageSize<br><br></p>
<h2 id="三、DECODE_函数">三、DECODE 函数</h2><p><strong><em>DECODE</em></strong><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECODE(expr,search1,result1[<span class="link_label">,search2,result2…</span>][<span class="link_reference">,default</span>])</span><br></pre></td></tr></table></figure></p>
<ul>
<li>DECODE用于比较参数expo的值，如果匹配到哪一个search条件，就返回对应的result结果</li>
<li>可以有多组search和result的对应关系，如果任何一个都没有匹配到，则返回最后default的值</li>
<li>default参数是可选的，如果没有提供default参数值，当没有匹配到时，将返回NULL<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">name</span>,job</span><br><span class="line"><span class="keyword">DECODE</span>(job,</span><br><span class="line">       <span class="string">'MANAGER'</span>,sal * <span class="number">1.2</span>,</span><br><span class="line">       <span class="string">'ANLYST'</span>,sal * <span class="number">1.1</span>,</span><br><span class="line">       <span class="string">'SALESMAN'</span>,sal * <span class="number">1.05</span>,</span><br><span class="line">       sal</span><br><span class="line">) bonus</span><br><span class="line"><span class="keyword">FROM</span> emp;</span></span><br></pre></td></tr></table></figure><br></li>
</ul>
<p><strong><em>和DECODE函数功能相似的有CASE语句</em></strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> ename,job,sal</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="string">'MANAGER'</span> <span class="keyword">THEN</span> sal * <span class="number">1.2</span></span><br><span class="line">     <span class="keyword">WHEN</span> <span class="string">'ANLYST'</span> <span class="keyword">THEN</span> sal * <span class="number">1.1</span></span><br><span class="line">     <span class="keyword">WHEN</span> <span class="string">'SALSMAN'</span> <span class="keyword">THEN</span> sal * <span class="number">1.05</span></span><br><span class="line">     <span class="keyword">ELSE</span> sal <span class="keyword">END</span></span><br><span class="line">     bonus</span><br><span class="line"><span class="keyword">FROM</span> emp;</span></span><br></pre></td></tr></table></figure></p>
<p>按字段内容分组<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">DECODE</span> (job,</span><br><span class="line">               <span class="string">'ANALYST'</span>,<span class="string">'VIP'</span>,</span><br><span class="line">               <span class="string">'MANAGER'</span>,<span class="string">'VIP'</span>,</span><br><span class="line">               <span class="string">'OPERATION'</span>),</span><br><span class="line">               job,<span class="keyword">COUNT</span>(*) job_cnt</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">DECODE</span>(job,</span><br><span class="line">                <span class="string">'ANALYST'</span>,<span class="string">'VIP'</span>,</span><br><span class="line">                <span class="string">'MANAGER'</span>,<span class="string">'VIP'</span></span><br><span class="line">                <span class="string">'OPERATION'</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>按字段内容排序<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> deptno,<span class="keyword">name</span>,loc</span><br><span class="line"><span class="keyword">FROM</span> dept</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">DECODE</span>(dname,</span><br><span class="line">                <span class="string">'OPERATIONS'</span>,<span class="number">1</span>,</span><br><span class="line">                <span class="string">'ACCOUNTING'</span>,<span class="number">2</span>,</span><br><span class="line">                <span class="string">'SALES'</span>,<span class="number">3</span>);</span></span><br></pre></td></tr></table></figure><br></p>
<h2 id="四、排序函数">四、排序函数</h2><p>可以根据指定的字段分组，再根据一个指定的字段排序，然后生成一个组内的编号。</p>
<p><strong><em>ROW_NUMBER</em></strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">ROW_NUMBER</span><span class="params">()</span></span> <span class="function"><span class="title">OVER</span><span class="params">(PARTITION BY col1 ORDER BY col2)</span></span></span><br></pre></td></tr></table></figure></p>
<p>表示根据col1分组，然后在分组内根据col2排序，生成组内连续且唯一的数字，排序也可以指定多个字段<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">name</span>,sal,deptno,ROW_NUMBER() <span class="keyword">OVER</span>(</span><br><span class="line">     <span class="keyword">PARTITION</span> <span class="keyword">BY</span> deptno</span><br><span class="line">     <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal <span class="keyword">DESC</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">FROM</span> emp</span></span><br></pre></td></tr></table></figure><br></p>
<p><strong><em>RANK 相同的数据返回相同排名，生成不连续也不唯一的数字</em></strong><br>跳跃排序，如果有相同数据，则排名相同，但下一个排名不变<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">name</span>,sal,deptno,ROW_NUMBER() <span class="keyword">OVER</span>(</span><br><span class="line">     <span class="keyword">PARTITION</span> <span class="keyword">BY</span> deptno</span><br><span class="line">     <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal <span class="keyword">DESC</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">FROM</span> emp</span></span><br></pre></td></tr></table></figure><br></p>
<p><strong><em>DENSE_RANK 相同的数据返回相同排名，生成连续但不唯一的数字</em></strong><br>如果有相同数据，则排名相同，但下一个排名连续<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">name</span>,sal,deptno,<span class="keyword">DENSE_RANK</span>() <span class="keyword">OVER</span>(</span><br><span class="line">     <span class="keyword">PARTITION</span> <span class="keyword">BY</span> deptno</span><br><span class="line">     <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal <span class="keyword">DESC</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">FROM</span> emp</span></span><br></pre></td></tr></table></figure><br></p>
<h2 id="五、集合操作">五、集合操作</h2><p><strong><em>UNION、UNION ALL 并集</em></strong><br>UNION 不包含重复元素，UNION ALL 包含重复元素<br>UNION操作符对查询结果排序，UNION ALL不排序<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename,job <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> job = <span class="string">'MANAGER'</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> ename,job <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> sal &gt; <span class="number">2500</span></span><br></pre></td></tr></table></figure><br></p>
<p><strong><em>INTERSECT 交集</em></strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> ename,job <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> job = <span class="string">'MANAGER'</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> ename,job <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> sal &gt; <span class="number">2500</span></span></span><br></pre></td></tr></table></figure><br></p>
<p><strong><em>MINUS 差集,只有在第一个集合中存在，第二个集合中不存在的才被显示</em></strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> ename,job <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> job = <span class="string">'MANAGER'</span></span><br><span class="line"><span class="keyword">MINUS</span></span><br><span class="line"><span class="keyword">SELECT</span> ename,job <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> sal &gt; <span class="number">2500</span></span></span><br></pre></td></tr></table></figure></p>
<p>使用并、交、差集时，必须保证结果集的字段相同<br><br></p>
<h2 id="六、高级分组函数">六、高级分组函数</h2><p>ROLLUP、CUBE和GROUPING SETS运算符是GROUP BY子句的扩展，可以生成与使用UNION ALL来组合单个分组查询时相同的结果集，用来简化和高效的实现统计查询</p>
<p><strong><em>ROLLUP</em></strong><br>GROUP BY ROLLUP（a,b,c） 的话，那么分组分别会按照：<br>GROUP BY a,b,c<br>GROUP BY a,b<br>GROUP BY a<br>最后将全表看做一组统一计算一次<br>然后再将上述的分组结果并在一个结果集，n个参数的ROLLUP有n+1次分组<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> a,b,<span class="keyword">c</span>,<span class="keyword">SUM</span>(<span class="keyword">d</span>) <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span>(a,b,<span class="keyword">c</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> a,b,<span class="keyword">c</span>,<span class="keyword">SUM</span>(<span class="keyword">d</span>) <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> a,b,<span class="keyword">c</span></span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line"><span class="keyword">SELECT</span> a,b,<span class="literal">null</span>,<span class="keyword">SUM</span>(<span class="keyword">d</span>) <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> a,b</span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line"><span class="keyword">SELECT</span> a,<span class="literal">null</span>,<span class="literal">null</span>,<span class="keyword">SUM</span>(<span class="keyword">d</span>) <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> a</span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line"><span class="keyword">SELECT</span> <span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,sun(<span class="keyword">d</span>) <span class="keyword">FROM</span> <span class="keyword">test</span></span></span><br></pre></td></tr></table></figure><br></p>
<p><strong><em>CUBE</em></strong><br>CUBE是将给定的参数字段的每种组合都进行一次分组，然后将这些组合统计的结果集并在一起显示，n个参数的CUBE有2^n次分组<br>GROUP BY CUBE（a,b,c） 的话，那么分组分别会按照：<br>GROUP BY a,b,c<br>GROUP BY a,b<br>GROUP BY a,c<br>GROUP BY a<br>GROUP BY b,c<br>GROUP BY b<br>GROUP BY c<br>最后对全表进行GROUP BY操作，一共是2^3=8次分组<br><br></p>
<p><strong><em>GROUPING SETS</em></strong><br>可以根据自定义的组合方式进行分组，然后将这些分组的结果并在一个结果集中显示,n个参数的GROUPING SETS有n次分组<br>GROUP BY GROUPING SETS（(a,b,c),(a,b)） 的话，那么分组分别会按照：<br>GROUP BY a,b,c<br>GROUP BY a,b<br>GROUPING SETS参数允许重复</p>
</div></article></div></section><footer><div class="paginator"><a href="/2015/12/22/数据库基础（五）/" class="prev">上一篇</a><a href="/2015/12/19/数据库基础（三）/" class="next">下一篇</a></div><div data-thread-key="2015/12/21/数据库基础（四）/" data-title="数据库基础（四）" data-url="http://hellowvirgil.github.io/2015/12/21/数据库基础（四）/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"true"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 <a href="http://hellowvirgil.github.io">Virgil</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>